<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Should I Text My Crush? - Interactive Decision Neuron</title>
<style>
  *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
  :root{
    --pink:#FF69B4;--soft-pink:#FFE4E8;--rose:#E91E63;
    --purple:#9C27B0;--light-purple:#E1BEE7;--lavender:#F3E5F5;
    --bg:#FFF5F7;--card:#fff;--text:#4A4A4A;--text-light:#888;
    --gold:#D4A574;--shadow:0 4px 20px rgba(156,39,176,.12);
    --radius:14px;
  }
  html{font-size:15px}
  body{font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:var(--bg);color:var(--text);min-height:100vh;overflow-x:hidden}
  h1,h2,h3{font-weight:700}

  /* ── Header ── */
  .header{text-align:center;padding:1.2rem 1rem .8rem;background:linear-gradient(135deg,var(--soft-pink),var(--lavender));border-bottom:2px solid var(--light-purple)}
  .header h1{font-size:1.6rem;color:var(--rose);margin-bottom:.2rem}
  .header p{font-size:.92rem;color:var(--purple);opacity:.85}

  /* ── Layout ── */
  .app{display:flex;gap:1.2rem;padding:1.2rem;max-width:1400px;margin:0 auto}
  .left-panel{flex:0 0 360px;display:flex;flex-direction:column;gap:1rem}
  .right-panel{flex:1;min-width:0;display:flex;flex-direction:column;gap:1rem}

  /* ── Cards ── */
  .card{background:var(--card);border-radius:var(--radius);padding:1rem 1.1rem;box-shadow:var(--shadow);border:1px solid rgba(255,105,180,.12)}
  .card h2{font-size:1rem;margin-bottom:.7rem;color:var(--purple);display:flex;align-items:center;gap:.4rem}
  .card h2 .icon{font-size:1.1rem}

  /* ── Label Toggle ── */
  .label-toggle{display:flex;gap:.5rem;margin-bottom:.8rem}
  .label-btn{flex:1;padding:.6rem .5rem;border:2px solid transparent;border-radius:10px;font-size:.85rem;font-weight:700;cursor:pointer;transition:all .25s;display:flex;align-items:center;justify-content:center;gap:.35rem}
  .label-btn.go{background:var(--soft-pink);color:var(--rose)}
  .label-btn.go.active{background:var(--rose);color:#fff;border-color:#c2185b;box-shadow:0 0 14px rgba(233,30,99,.35)}
  .label-btn.hold{background:var(--lavender);color:var(--purple)}
  .label-btn.hold.active{background:var(--purple);color:#fff;border-color:#7b1fa2;box-shadow:0 0 14px rgba(156,39,176,.35)}

  /* ── Buttons ── */
  .btn{padding:.55rem 1rem;border:none;border-radius:10px;font-size:.85rem;font-weight:700;cursor:pointer;transition:all .2s;display:inline-flex;align-items:center;gap:.3rem}
  .btn:disabled{opacity:.45;cursor:not-allowed;transform:none!important}
  .btn:hover:not(:disabled){transform:translateY(-1px)}
  .btn-primary{background:linear-gradient(135deg,var(--rose),var(--pink));color:#fff;font-size:.95rem;padding:.7rem 1.4rem;box-shadow:0 3px 12px rgba(233,30,99,.3)}
  .btn-secondary{background:linear-gradient(135deg,var(--purple),#BA68C8);color:#fff;box-shadow:0 3px 10px rgba(156,39,176,.25)}
  .btn-danger{background:#f5f5f5;color:#999;border:1px solid #ddd;font-size:.78rem}
  .btn-danger:hover:not(:disabled){background:#fce4ec;color:var(--rose);border-color:var(--rose)}
  .training-btns{display:flex;gap:.5rem;flex-wrap:wrap;margin-bottom:.2rem}

  /* ── Sliders ── */
  .slider-group{margin-bottom:.6rem}
  .slider-label{display:flex;justify-content:space-between;font-size:.8rem;margin-bottom:.25rem;color:var(--text-light);font-weight:600}
  .slider-label span:last-child{color:var(--purple);font-weight:700}
  input[type=range]{-webkit-appearance:none;width:100%;height:6px;border-radius:3px;background:linear-gradient(90deg,var(--soft-pink),var(--light-purple));outline:none}
  input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:var(--rose);cursor:pointer;box-shadow:0 2px 6px rgba(233,30,99,.3)}
  input[type=range]::-moz-range-thumb{width:18px;height:18px;border-radius:50%;background:var(--rose);cursor:pointer;border:none}

  /* ── Init Options ── */
  .init-row{display:flex;gap:.4rem;margin-bottom:.6rem}
  .init-btn{flex:1;padding:.4rem;border:1.5px solid var(--light-purple);border-radius:8px;background:var(--card);font-size:.72rem;font-weight:600;color:var(--purple);cursor:pointer;transition:all .2s}
  .init-btn.active,.init-btn:hover{background:var(--lavender);border-color:var(--purple)}

  /* ── Metrics ── */
  .metric-row{display:flex;justify-content:space-between;align-items:center;padding:.35rem 0;border-bottom:1px solid rgba(255,105,180,.08);font-size:.82rem}
  .metric-row:last-child{border-bottom:none}
  .metric-row .name{display:flex;align-items:center;gap:.3rem}
  .metric-row .val{font-weight:700;color:var(--purple);font-variant-numeric:tabular-nums;transition:color .3s}
  .metric-row .val.positive{color:#43a047}
  .metric-row .val.negative{color:var(--rose)}
  .stat-row{display:flex;gap:.8rem;margin-top:.5rem}
  .stat-box{flex:1;text-align:center;padding:.5rem;background:var(--lavender);border-radius:10px}
  .stat-box .num{font-size:1.2rem;font-weight:800;color:var(--purple)}
  .stat-box .lbl{font-size:.68rem;color:var(--text-light);font-weight:600}

  /* ── Plot ── */
  .plot-wrap{position:relative;background:var(--card);border-radius:var(--radius);box-shadow:var(--shadow);border:1px solid rgba(255,105,180,.12);padding:.6rem}
  .plot-container{position:relative;width:100%;aspect-ratio:1/1;max-height:560px}
  canvas.plot-canvas{width:100%;height:100%;border-radius:10px;cursor:crosshair;display:block}
  .plot-label{position:absolute;font-size:.72rem;font-weight:700;color:var(--text-light)}
  .plot-label.x-label{bottom:-1.4rem;left:50%;transform:translateX(-50%)}
  .plot-label.y-label{left:-2.8rem;top:50%;transform:translateY(-50%) rotate(-90deg);white-space:nowrap}
  .plot-legend{display:flex;gap:1rem;justify-content:center;margin-top:.5rem;font-size:.78rem;font-weight:600}
  .plot-legend span{display:flex;align-items:center;gap:.3rem}
  .legend-dot{width:10px;height:10px;border-radius:50%;display:inline-block}

  .tooltip{position:fixed;background:rgba(74,74,74,.95);color:#fff;padding:.5rem .7rem;border-radius:8px;font-size:.72rem;line-height:1.5;pointer-events:none;z-index:100;opacity:0;transition:opacity .15s;white-space:nowrap;backdrop-filter:blur(4px)}
  .tooltip.show{opacity:1}

  /* ── Sensitivity ── */
  .sensitivity-toggle{width:100%;margin-top:.3rem}
  .sensitivity-panel{overflow:hidden;max-height:0;transition:max-height .4s ease-in-out;margin-top:.6rem}
  .sensitivity-panel.open{max-height:600px}
  .sensitivity-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:.6rem}
  .mini-chart{background:var(--lavender);border-radius:10px;padding:.5rem;text-align:center}
  .mini-chart .chart-title{font-size:.7rem;font-weight:700;color:var(--purple);margin-bottom:.3rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .mini-chart canvas{width:100%;height:80px;border-radius:6px;background:#fff}
  .mini-chart .score{font-size:.65rem;color:var(--text-light);margin-top:.2rem}

  /* ── Status ── */
  .status-bar{text-align:center;font-size:.78rem;font-weight:600;padding:.3rem;border-radius:8px;transition:all .3s}
  .status-bar.idle{color:var(--text-light)}
  .status-bar.training{color:var(--rose);background:var(--soft-pink)}
  .status-bar.done{color:#43a047;background:#e8f5e9}

  /* ── Responsive ── */
  @media(max-width:900px){
    .app{flex-direction:column}
    .left-panel{flex:none;width:100%}
    .sensitivity-grid{grid-template-columns:repeat(2,1fr)}
  }
  @media(max-width:500px){
    html{font-size:14px}
    .header h1{font-size:1.3rem}
    .left-panel{flex:none}
    .sensitivity-grid{grid-template-columns:repeat(2,1fr)}
    .mini-chart:last-child{grid-column:span 2}
  }

  /* ── Animations ── */
  @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.15)}}
  @keyframes dropIn{0%{transform:scale(0);opacity:0}60%{transform:scale(1.2)}100%{transform:scale(1);opacity:1}}
  .pulse{animation:pulse .5s ease-in-out}
</style>
</head>
<body>

<div class="header">
  <h1>Should I Text My Crush?</h1>
  <p>Interactive Decision Neuron &mdash; Train a single neuron to decide for you</p>
</div>

<div class="app">
  <!-- LEFT PANEL -->
  <div class="left-panel">

    <!-- Setup -->
    <div class="card">
      <h2><span class="icon">&#9881;</span> Setup</h2>

      <div style="font-size:.78rem;font-weight:600;color:var(--text-light);margin-bottom:.3rem">Weight Initialization</div>
      <div class="init-row">
        <button class="init-btn active" data-init="random" onclick="setInit('random')">Random</button>
        <button class="init-btn" data-init="smart" onclick="setInit('smart')">Smart Defaults</button>
        <button class="init-btn" data-init="zero" onclick="setInit('zero')">Zeros</button>
      </div>

      <div class="slider-group">
        <div class="slider-label"><span>Baseline Tendency (Bias)</span><span id="biasVal">0.00</span></div>
        <input type="range" id="biasSlider" min="-5" max="5" step="0.1" value="0" oninput="setBias(this.value)">
      </div>
      <div class="slider-group">
        <div class="slider-label"><span>Learning Rate</span><span id="lrVal">0.10</span></div>
        <input type="range" id="lrSlider" min="0.01" max="1" step="0.01" value="0.1" oninput="setLR(this.value)">
      </div>
    </div>

    <!-- Training -->
    <div class="card">
      <h2><span class="icon">&#9889;</span> Training</h2>
      <div style="font-size:.78rem;color:var(--text-light);margin-bottom:.5rem">Select a label, then click the plot to add points</div>

      <div class="label-toggle">
        <button class="label-btn go active" id="btnGo" onclick="setLabel(1)">&#10084; GO FOR IT</button>
        <button class="label-btn hold" id="btnHold" onclick="setLabel(0)">&#128156; HOLD OFF</button>
      </div>

      <div class="training-btns">
        <button class="btn btn-primary" id="btnStep" onclick="trainStep()" disabled>Step</button>
        <button class="btn btn-secondary" id="btnTrain" onclick="trainMultiple()" disabled>Train &times;10</button>
        <button class="btn btn-danger" id="btnReset" onclick="resetAll()">Reset</button>
      </div>
      <div class="status-bar idle" id="status">Add points to the plot to begin</div>
    </div>

    <!-- Metrics -->
    <div class="card">
      <h2><span class="icon">&#128202;</span> Neuron Weights</h2>
      <div id="weightsList">
        <div class="metric-row"><span class="name">&#128170; Confidence</span><span class="val" id="w0">0.00</span></div>
        <div class="metric-row"><span class="name">&#9200; Time Since Last</span><span class="val" id="w1">0.00</span></div>
        <div class="metric-row"><span class="name">&#128149; Interest Level</span><span class="val" id="w2">0.00</span></div>
        <div class="metric-row"><span class="name">&#128336; Time of Day</span><span class="val" id="w3">0.00</span></div>
        <div class="metric-row"><span class="name">&#128560; Anxiety/Fear</span><span class="val" id="w4">0.00</span></div>
        <div class="metric-row"><span class="name">&#127919; Bias</span><span class="val" id="wBias">0.00</span></div>
      </div>
      <div class="stat-row">
        <div class="stat-box"><div class="num" id="stepCount">0</div><div class="lbl">Steps</div></div>
        <div class="stat-box"><div class="num" id="accuracy">--</div><div class="lbl">Accuracy</div></div>
        <div class="stat-box"><div class="num" id="pointCount">0</div><div class="lbl">Points</div></div>
      </div>
    </div>

    <!-- Sensitivity -->
    <div class="card">
      <button class="btn btn-secondary sensitivity-toggle" id="sensToggle" onclick="toggleSensitivity()">&#128202; Show Sensitivity Analysis</button>
      <div class="sensitivity-panel" id="sensPanel">
        <div class="sensitivity-grid" id="sensGrid"></div>
      </div>
    </div>

  </div>

  <!-- RIGHT PANEL -->
  <div class="right-panel">
    <div class="plot-wrap">
      <div style="font-size:.85rem;font-weight:700;color:var(--purple);margin-bottom:.4rem;text-align:center">Decision Boundary &mdash; Click to add points</div>
      <div class="plot-container" id="plotContainer">
        <canvas class="plot-canvas" id="mainCanvas"></canvas>
      </div>
      <div class="plot-legend">
        <span><span class="legend-dot" style="background:var(--rose)"></span> GO FOR IT</span>
        <span><span class="legend-dot" style="background:var(--purple)"></span> HOLD OFF</span>
      </div>
    </div>
  </div>
</div>

<div class="tooltip" id="tooltip"></div>

<script>
/* ═══════════════════════════════════════════
   Interactive Decision Neuron
   "Should I text my crush?"
   ═══════════════════════════════════════════ */

// ── State ──
const FEATURES = [
  { name: 'Confidence', icon: '\u{1F4AA}', expectedSign: 1 },
  { name: 'Time Since Last', icon: '\u23F0', expectedSign: 1 },
  { name: 'Interest Level', icon: '\u{1F495}', expectedSign: 1 },
  { name: 'Time of Day', icon: '\u{1F550}', expectedSign: 1 },
  { name: 'Anxiety/Fear', icon: '\u{1F630}', expectedSign: -1 },
];
const FIXED = { timeSince: 5, timeOfDay: 7, anxiety: 5 }; // fixed values for non-plotted axes

let weights = [0, 0, 0, 0, 0];
let bias = 0;
let learningRate = 0.1;
let currentLabel = 1; // 1 = go, 0 = hold
let points = []; // { x, y, label, inputs:[5] }
let stepCounter = 0;
let isTraining = false;
let initMode = 'random';
let sensOpen = false;

// ── Canvas Setup ──
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
const MARGIN = { top: 20, right: 20, bottom: 40, left: 50 };

function resizeCanvas() {
  const container = document.getElementById('plotContainer');
  const w = container.clientWidth;
  const h = container.clientHeight;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  render();
}
window.addEventListener('resize', resizeCanvas);

// ── Math ──
function sigmoid(z) { return 1 / (1 + Math.exp(-z)); }
function predict(inputs) {
  let z = bias;
  for (let i = 0; i < 5; i++) z += weights[i] * inputs[i];
  return sigmoid(z);
}
function makeInputs(confidence, interest) {
  return [confidence, FIXED.timeSince, interest, FIXED.timeOfDay, FIXED.anxiety];
}

// ── Init ──
function setInit(mode) {
  initMode = mode;
  document.querySelectorAll('.init-btn').forEach(b => b.classList.toggle('active', b.dataset.init === mode));
  initWeights();
}
function initWeights() {
  if (initMode === 'random') {
    weights = Array.from({ length: 5 }, () => (Math.random() - 0.5));
  } else if (initMode === 'smart') {
    weights = FEATURES.map(f => f.expectedSign * (Math.random() * 0.3 + 0.2));
  } else {
    weights = [0, 0, 0, 0, 0];
  }
  bias = parseFloat(document.getElementById('biasSlider').value);
  stepCounter = 0;
  updateMetrics();
  render();
}

// ── Controls ──
function setBias(v) {
  bias = parseFloat(v);
  document.getElementById('biasVal').textContent = bias.toFixed(2);
  updateMetrics();
  render();
}
function setLR(v) {
  learningRate = parseFloat(v);
  document.getElementById('lrVal').textContent = learningRate.toFixed(2);
}
function setLabel(l) {
  currentLabel = l;
  document.getElementById('btnGo').classList.toggle('active', l === 1);
  document.getElementById('btnHold').classList.toggle('active', l === 0);
}

// ── Training ──
function trainStep() {
  if (points.length === 0) return;
  for (const p of points) {
    const pred = predict(p.inputs);
    const error = p.label - pred;
    for (let i = 0; i < 5; i++) {
      weights[i] += learningRate * error * p.inputs[i];
    }
    bias += learningRate * error;
  }
  // Sync bias slider
  const clamped = Math.max(-5, Math.min(5, bias));
  document.getElementById('biasSlider').value = clamped;
  document.getElementById('biasVal').textContent = bias.toFixed(2);

  stepCounter++;
  updateMetrics();
  render();
}

async function trainMultiple() {
  if (points.length === 0) return;
  if (isTraining) { isTraining = false; return; }
  isTraining = true;
  const btn = document.getElementById('btnTrain');
  btn.textContent = '\u25A0 Stop';
  setStatus('training', 'Training...');

  for (let i = 0; i < 10; i++) {
    if (!isTraining) break;
    trainStep();
    await sleep(200);
  }
  isTraining = false;
  btn.textContent = 'Train \u00d710';
  setStatus('done', 'Training complete!');
  setTimeout(() => { if (!isTraining) setStatus('idle', 'Ready'); }, 1500);
}

function resetAll() {
  points = [];
  stepCounter = 0;
  isTraining = false;
  document.getElementById('btnTrain').textContent = 'Train \u00d710';
  initWeights();
  updateButtons();
  setStatus('idle', 'Add points to the plot to begin');
  render();
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

function setStatus(cls, text) {
  const el = document.getElementById('status');
  el.className = 'status-bar ' + cls;
  el.textContent = text;
}

function updateButtons() {
  const hasPoints = points.length > 0;
  document.getElementById('btnStep').disabled = !hasPoints;
  document.getElementById('btnTrain').disabled = !hasPoints;
}

// ── Metrics ──
function updateMetrics() {
  for (let i = 0; i < 5; i++) {
    const el = document.getElementById('w' + i);
    el.textContent = (weights[i] >= 0 ? '+' : '') + weights[i].toFixed(3);
    el.className = 'val ' + (weights[i] >= 0 ? 'positive' : 'negative');
  }
  const bEl = document.getElementById('wBias');
  bEl.textContent = (bias >= 0 ? '+' : '') + bias.toFixed(3);
  bEl.className = 'val ' + (bias >= 0 ? 'positive' : 'negative');

  document.getElementById('stepCount').textContent = stepCounter;
  document.getElementById('pointCount').textContent = points.length;

  if (points.length > 0) {
    let correct = 0;
    for (const p of points) {
      const pred = predict(p.inputs);
      if ((pred >= 0.5 && p.label === 1) || (pred < 0.5 && p.label === 0)) correct++;
    }
    const acc = (correct / points.length * 100).toFixed(1);
    document.getElementById('accuracy').textContent = acc + '%';
  } else {
    document.getElementById('accuracy').textContent = '--';
  }
  if (sensOpen) renderSensitivity();
}

// ── Plot Coordinates ──
function plotW() { return canvas.width / (window.devicePixelRatio || 1) - MARGIN.left - MARGIN.right; }
function plotH() { return canvas.height / (window.devicePixelRatio || 1) - MARGIN.top - MARGIN.bottom; }
function toCanvasX(v) { return MARGIN.left + (v / 10) * plotW(); }
function toCanvasY(v) { return MARGIN.top + plotH() - (v / 10) * plotH(); }
function toDataX(cx) { return Math.max(0, Math.min(10, ((cx - MARGIN.left) / plotW()) * 10)); }
function toDataY(cy) { return Math.max(0, Math.min(10, ((MARGIN.top + plotH() - cy) / plotH()) * 10)); }

// ── Rendering ──
let animTarget = null;
let animWeights = [...weights];
let animBias = bias;

function render() {
  const w = canvas.width / (window.devicePixelRatio || 1);
  const h = canvas.height / (window.devicePixelRatio || 1);
  ctx.clearRect(0, 0, w, h);

  drawRegions(w, h);
  drawGrid(w, h);
  drawBoundary(w, h);
  drawAxes(w, h);
  drawPoints();
}

function drawRegions(w, h) {
  const pw = plotW();
  const ph = plotH();
  const res = 4; // pixel step for performance
  for (let px = 0; px < pw; px += res) {
    for (let py = 0; py < ph; py += res) {
      const dx = (px / pw) * 10;
      const dy = ((ph - py) / ph) * 10;
      const prob = predict(makeInputs(dx, dy));
      if (prob >= 0.5) {
        ctx.fillStyle = `rgba(255,228,232,${0.25 + (prob - 0.5) * 0.9})`;
      } else {
        ctx.fillStyle = `rgba(243,229,245,${0.25 + (0.5 - prob) * 0.9})`;
      }
      ctx.fillRect(MARGIN.left + px, MARGIN.top + py, res, res);
    }
  }
}

function drawGrid(w, h) {
  ctx.strokeStyle = 'rgba(156,39,176,0.08)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 10; i++) {
    const x = toCanvasX(i);
    const y = toCanvasY(i);
    ctx.beginPath(); ctx.moveTo(x, MARGIN.top); ctx.lineTo(x, MARGIN.top + plotH()); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(MARGIN.left, y); ctx.lineTo(MARGIN.left + plotW(), y); ctx.stroke();
  }
}

function drawBoundary(w, h) {
  // Decision boundary: w0*x + w2*y + w1*5 + w3*7 + w4*5 + bias = 0
  // y = -(w0*x + w1*5 + w3*7 + w4*5 + bias) / w2
  if (Math.abs(weights[2]) < 0.001) return; // near-horizontal or degenerate

  ctx.save();
  ctx.beginPath();
  ctx.rect(MARGIN.left, MARGIN.top, plotW(), plotH());
  ctx.clip();

  const pts = [];
  for (let px = -1; px <= 11; px += 0.2) {
    const y = -(weights[0] * px + weights[1] * FIXED.timeSince + weights[3] * FIXED.timeOfDay + weights[4] * FIXED.anxiety + bias) / weights[2];
    pts.push({ x: px, y });
  }

  ctx.strokeStyle = 'rgba(233,30,99,0.7)';
  ctx.lineWidth = 2.5;
  ctx.setLineDash([6, 4]);
  ctx.beginPath();
  let started = false;
  for (const p of pts) {
    const cx = toCanvasX(p.x);
    const cy = toCanvasY(p.y);
    if (!started) { ctx.moveTo(cx, cy); started = true; } else ctx.lineTo(cx, cy);
  }
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();
}

function drawAxes(w, h) {
  ctx.strokeStyle = 'rgba(74,74,74,0.3)';
  ctx.lineWidth = 1.5;
  // X axis
  ctx.beginPath();
  ctx.moveTo(MARGIN.left, MARGIN.top + plotH());
  ctx.lineTo(MARGIN.left + plotW(), MARGIN.top + plotH());
  ctx.stroke();
  // Y axis
  ctx.beginPath();
  ctx.moveTo(MARGIN.left, MARGIN.top);
  ctx.lineTo(MARGIN.left, MARGIN.top + plotH());
  ctx.stroke();

  ctx.fillStyle = '#888';
  ctx.font = '11px "Segoe UI", system-ui, sans-serif';
  ctx.textAlign = 'center';
  for (let i = 0; i <= 10; i += 2) {
    ctx.fillText(i, toCanvasX(i), MARGIN.top + plotH() + 16);
  }
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for (let i = 0; i <= 10; i += 2) {
    ctx.fillText(i, MARGIN.left - 8, toCanvasY(i));
  }

  // Labels
  ctx.fillStyle = '#4A4A4A';
  ctx.font = 'bold 12px "Segoe UI", system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText('\u{1F4AA} Confidence Level', MARGIN.left + plotW() / 2, MARGIN.top + plotH() + 26);
  ctx.save();
  ctx.translate(14, MARGIN.top + plotH() / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textBaseline = 'middle';
  ctx.fillText('\u{1F495} Likelihood Interested', 0, 0);
  ctx.restore();
}

function drawPoints() {
  for (const p of points) {
    const cx = toCanvasX(p.inputs[0]);
    const cy = toCanvasY(p.inputs[2]);
    const r = 7;
    ctx.beginPath();
    if (p.label === 1) {
      // Heart shape for "go"
      drawHeart(cx, cy, r, 'rgba(233,30,99,0.9)', 'rgba(233,30,99,0.15)');
    } else {
      drawHeart(cx, cy, r, 'rgba(156,39,176,0.9)', 'rgba(156,39,176,0.15)');
    }
  }
}

function drawHeart(cx, cy, size, fill, stroke) {
  ctx.save();
  ctx.fillStyle = fill;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2;
  ctx.beginPath();
  const s = size * 0.9;
  const topY = cy - s * 0.4;
  ctx.moveTo(cx, cy + s * 0.6);
  ctx.bezierCurveTo(cx - s * 1.2, cy - s * 0.2, cx - s * 0.7, topY - s * 0.7, cx, topY + s * 0.1);
  ctx.bezierCurveTo(cx + s * 0.7, topY - s * 0.7, cx + s * 1.2, cy - s * 0.2, cx, cy + s * 0.6);
  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

// ── Interaction ──
canvas.addEventListener('click', function (e) {
  if (isTraining) return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  // Check if clicking an existing point to toggle
  for (const p of points) {
    const px = toCanvasX(p.inputs[0]);
    const py = toCanvasY(p.inputs[2]);
    if (Math.hypot(mx - px, my - py) < 12) {
      p.label = p.label === 1 ? 0 : 1;
      updateButtons();
      updateMetrics();
      render();
      return;
    }
  }

  const dx = toDataX(mx);
  const dy = toDataY(my);
  if (dx < 0 || dx > 10 || dy < 0 || dy > 10) return;

  const inputs = makeInputs(dx, dy);
  points.push({ inputs, label: currentLabel });
  updateButtons();
  updateMetrics();
  render();
  setStatus('idle', `${points.length} point${points.length > 1 ? 's' : ''} \u2014 Ready to train`);
});

// Tooltip
let hoveredPoint = null;
canvas.addEventListener('mousemove', function (e) {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const tip = document.getElementById('tooltip');

  let found = null;
  for (const p of points) {
    const px = toCanvasX(p.inputs[0]);
    const py = toCanvasY(p.inputs[2]);
    if (Math.hypot(mx - px, my - py) < 12) { found = p; break; }
  }

  if (found) {
    const prob = predict(found.inputs);
    tip.innerHTML = `<b>${found.label === 1 ? '\u2764 GO FOR IT' : '\u{1F49C} HOLD OFF'}</b><br>` +
      `\u{1F4AA} Confidence: ${found.inputs[0].toFixed(1)}<br>` +
      `\u23F0 Time Since: ${found.inputs[1].toFixed(1)}<br>` +
      `\u{1F495} Interest: ${found.inputs[2].toFixed(1)}<br>` +
      `\u{1F550} Time of Day: ${found.inputs[3].toFixed(1)}<br>` +
      `\u{1F630} Anxiety: ${found.inputs[4].toFixed(1)}<br>` +
      `Prediction: ${(prob * 100).toFixed(1)}%`;
    tip.style.left = (e.clientX + 14) + 'px';
    tip.style.top = (e.clientY - 10) + 'px';
    tip.classList.add('show');
    canvas.style.cursor = 'pointer';
  } else {
    tip.classList.remove('show');
    canvas.style.cursor = 'crosshair';
  }
});
canvas.addEventListener('mouseleave', () => {
  document.getElementById('tooltip').classList.remove('show');
});

// ── Sensitivity Analysis ──
function toggleSensitivity() {
  sensOpen = !sensOpen;
  document.getElementById('sensPanel').classList.toggle('open', sensOpen);
  document.getElementById('sensToggle').textContent = sensOpen ? '\u{1F4CA} Hide Sensitivity Analysis' : '\u{1F4CA} Show Sensitivity Analysis';
  if (sensOpen) buildSensCharts();
}

function buildSensCharts() {
  const grid = document.getElementById('sensGrid');
  grid.innerHTML = '';
  for (let i = 0; i < 5; i++) {
    const div = document.createElement('div');
    div.className = 'mini-chart';
    div.innerHTML = `<div class="chart-title">${FEATURES[i].icon} ${FEATURES[i].name}</div>
      <canvas id="sensCanvas${i}" width="300" height="160"></canvas>
      <div class="score" id="sensScore${i}"></div>`;
    grid.appendChild(div);
  }
  renderSensitivity();
}

function renderSensitivity() {
  const defaults = [5, FIXED.timeSince, 5, FIXED.timeOfDay, FIXED.anxiety]; // default sweep center
  for (let fi = 0; fi < 5; fi++) {
    const c = document.getElementById('sensCanvas' + fi);
    if (!c) return;
    const cx = c.getContext('2d');
    const w = c.width;
    const h = c.height;
    const pad = { top: 8, bottom: 18, left: 28, right: 8 };
    cx.clearRect(0, 0, w, h);

    const dataPoints = [];
    let minP = 1, maxP = 0;
    for (let v = 0; v <= 10; v += 0.5) {
      const inputs = [...defaults];
      inputs[fi] = v;
      const prob = predict(inputs);
      dataPoints.push({ v, prob });
      if (prob < minP) minP = prob;
      if (prob > maxP) maxP = prob;
    }

    const pw = w - pad.left - pad.right;
    const ph = h - pad.top - pad.bottom;

    // Y axis (0-100%)
    cx.strokeStyle = 'rgba(156,39,176,0.15)';
    cx.lineWidth = 0.5;
    cx.font = '10px sans-serif';
    cx.fillStyle = '#aaa';
    cx.textAlign = 'right';
    for (let p = 0; p <= 100; p += 25) {
      const y = pad.top + ph - (p / 100) * ph;
      cx.beginPath(); cx.moveTo(pad.left, y); cx.lineTo(pad.left + pw, y); cx.stroke();
      cx.fillText(p + '%', pad.left - 3, y + 3);
    }
    // X axis
    cx.textAlign = 'center';
    for (let v = 0; v <= 10; v += 5) {
      const x = pad.left + (v / 10) * pw;
      cx.fillText(v, x, h - 3);
    }

    // Gradient line
    const grad = cx.createLinearGradient(pad.left, 0, pad.left + pw, 0);
    grad.addColorStop(0, '#E91E63');
    grad.addColorStop(1, '#9C27B0');
    cx.strokeStyle = grad;
    cx.lineWidth = 2.5;
    cx.beginPath();
    for (let j = 0; j < dataPoints.length; j++) {
      const x = pad.left + (dataPoints[j].v / 10) * pw;
      const y = pad.top + ph - dataPoints[j].prob * ph;
      if (j === 0) cx.moveTo(x, y); else cx.lineTo(x, y);
    }
    cx.stroke();

    // Default marker
    const defV = defaults[fi];
    const defProb = predict(defaults);
    const mx = pad.left + (defV / 10) * pw;
    cx.strokeStyle = 'rgba(233,30,99,0.4)';
    cx.lineWidth = 1;
    cx.setLineDash([3, 3]);
    cx.beginPath(); cx.moveTo(mx, pad.top); cx.lineTo(mx, pad.top + ph); cx.stroke();
    cx.setLineDash([]);

    // Score
    const score = ((maxP - minP) * 100).toFixed(0);
    const scoreEl = document.getElementById('sensScore' + fi);
    if (scoreEl) scoreEl.textContent = `Sensitivity: ${score}%`;
  }
}

// ── Init ──
function init() {
  initWeights();
  resizeCanvas();
  updateButtons();
}
init();
</script>
</body>
</html>
