<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecosystem Snake</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0f0f1a;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
        }

        #gameCanvas {
            background: #1a1a2e;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            display: block;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            color: #f0f0f0;
            font-size: 14px;
            pointer-events: none;
        }

        #hud .left, #hud .right {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #hud .right {
            text-align: right;
        }

        #hud .score {
            font-size: 24px;
            font-weight: bold;
            color: #0ea5e9;
        }

        #hud .high-score {
            color: #fbbf24;
        }

        #bottomHud {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            color: #f0f0f0;
            font-size: 14px;
            pointer-events: none;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 15, 26, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
        }

        .overlay.hidden {
            display: none;
        }

        .overlay h1 {
            color: #0ea5e9;
            font-size: 48px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(14, 165, 233, 0.5);
        }

        .overlay h2 {
            color: #f0f0f0;
            font-size: 24px;
            margin-bottom: 30px;
        }

        .overlay p {
            color: #888;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .overlay .subtitle {
            color: #06b6d4;
            font-size: 16px;
            margin-bottom: 30px;
        }

        .menu-btn {
            background: linear-gradient(135deg, #0ea5e9, #06b6d4);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .menu-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(14, 165, 233, 0.5);
        }

        .menu-btn.secondary {
            background: linear-gradient(135deg, #374151, #4b5563);
        }

        .difficulty-select {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }

        .difficulty-btn {
            background: #16213e;
            color: #f0f0f0;
            border: 2px solid #3b82f6;
            padding: 10px 20px;
            font-size: 14px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .difficulty-btn:hover, .difficulty-btn.selected {
            background: #3b82f6;
        }

        .controls-info {
            color: #666;
            font-size: 12px;
            margin-top: 30px;
        }

        .stats {
            color: #888;
            font-size: 14px;
            margin: 20px 0;
            text-align: center;
        }

        .stats span {
            color: #0ea5e9;
            font-weight: bold;
        }

        .final-score {
            font-size: 64px;
            color: #fbbf24;
            font-weight: bold;
            text-shadow: 0 0 30px rgba(251, 191, 36, 0.5);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div id="hud">
            <div class="left">
                <div>Score: <span class="score" id="scoreDisplay">0</span></div>
                <div>Size: <span id="sizeDisplay">3</span></div>
            </div>
            <div class="right">
                <div class="high-score">Best: <span id="highScoreDisplay">0</span></div>
                <div>Time: <span id="timeDisplay">0:00</span></div>
            </div>
        </div>

        <div id="bottomHud">
            <div>Snakes: <span id="snakeCount">1</span></div>
            <div>Press <strong>P</strong> to pause</div>
        </div>

        <!-- Start Menu -->
        <div class="overlay" id="startMenu">
            <h1>Ecosystem Snake</h1>
            <p class="subtitle">Survive and dominate the food chain</p>

            <div class="difficulty-select">
                <button class="difficulty-btn" data-difficulty="peaceful">Peaceful</button>
                <button class="difficulty-btn selected" data-difficulty="balanced">Balanced</button>
                <button class="difficulty-btn" data-difficulty="ecosystem">Ecosystem</button>
                <button class="difficulty-btn" data-difficulty="apex">Apex</button>
            </div>

            <button class="menu-btn" id="startBtn">Start Game</button>

            <div class="controls-info">
                <p>Arrow Keys or WASD to move</p>
                <p>Eat food to grow | Hunt smaller snakes | Avoid larger ones</p>
            </div>
        </div>

        <!-- Pause Menu -->
        <div class="overlay hidden" id="pauseMenu">
            <h2>Paused</h2>
            <button class="menu-btn" id="resumeBtn">Resume</button>
            <button class="menu-btn secondary" id="restartBtn">Restart</button>
        </div>

        <!-- Game Over -->
        <div class="overlay hidden" id="gameOverMenu">
            <h2>Game Over</h2>
            <div class="final-score" id="finalScore">0</div>
            <div class="stats">
                <p>Time Survived: <span id="finalTime">0:00</span></p>
                <p>Max Size: <span id="finalSize">0</span></p>
                <p>Snakes Eaten: <span id="snakesEaten">0</span></p>
                <p>Food Collected: <span id="foodCollected">0</span></p>
            </div>
            <button class="menu-btn" id="playAgainBtn">Play Again</button>
        </div>
    </div>

    <script>
        // ============================================
        // CONSTANTS
        // ============================================
        const GRID_WIDTH = 40;
        const GRID_HEIGHT = 30;
        const CELL_SIZE = 20;
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;

        const COLORS = {
            background: '#1a1a2e',
            gridLines: '#16213e',
            player: { primary: '#0ea5e9', secondary: '#06b6d4', glow: 'rgba(14, 165, 233, 0.3)' },
            food: { standard: '#fbbf24', golden: '#f59e0b', glow: 'rgba(251, 191, 36, 0.5)' },
            aiColors: [
                { primary: '#ef4444', secondary: '#f87171' },
                { primary: '#22c55e', secondary: '#4ade80' },
                { primary: '#a855f7', secondary: '#c084fc' },
                { primary: '#f97316', secondary: '#fb923c' },
                { primary: '#ec4899', secondary: '#f472b6' },
                { primary: '#14b8a6', secondary: '#2dd4bf' }
            ]
        };

        const DIFFICULTY_SETTINGS = {
            peaceful: { aiCount: 2, foodSpawnRate: 1500, aiSpeed: 0.8, foodMax: 15 },
            balanced: { aiCount: 4, foodSpawnRate: 2500, aiSpeed: 1.0, foodMax: 10 },
            ecosystem: { aiCount: 6, foodSpawnRate: 3000, aiSpeed: 1.1, foodMax: 8 },
            apex: { aiCount: 5, foodSpawnRate: 3500, aiSpeed: 1.2, foodMax: 6 }
        };

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function distance(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function randomPosition(avoid = []) {
            let pos;
            let attempts = 0;
            do {
                pos = { x: randomInt(1, GRID_WIDTH - 2), y: randomInt(1, GRID_HEIGHT - 2) };
                attempts++;
            } while (avoid.some(p => p.x === pos.x && p.y === pos.y) && attempts < 100);
            return pos;
        }

        // ============================================
        // SNAKE CLASS
        // ============================================
        class Snake {
            constructor(x, y, isPlayer = false, colorSet = null) {
                this.body = [{ x, y }];
                this.direction = { x: 1, y: 0 };
                this.nextDirection = { x: 1, y: 0 };
                this.isPlayer = isPlayer;
                this.alive = true;
                this.growQueue = 2;
                this.colors = colorSet || COLORS.player;
                this.moveTimer = 0;
                this.baseSpeed = isPlayer ? 8 : 7;
                this.eyeDirection = { x: 1, y: 0 };
            }

            get head() {
                return this.body[0];
            }

            get length() {
                return this.body.length;
            }

            get speed() {
                const sizePenalty = Math.floor(this.length / 15) * 0.5;
                return Math.max(this.baseSpeed - sizePenalty, 4);
            }

            setDirection(dir) {
                if (dir.x !== -this.direction.x || dir.y !== -this.direction.y) {
                    if (dir.x !== 0 || dir.y !== 0) {
                        this.nextDirection = { ...dir };
                    }
                }
            }

            update(deltaTime, gameSpeed = 1) {
                if (!this.alive) return;

                this.moveTimer += deltaTime * this.speed * gameSpeed;

                if (this.moveTimer >= 1) {
                    this.moveTimer = 0;
                    this.move();
                }
            }

            move() {
                this.direction = { ...this.nextDirection };
                this.eyeDirection = { ...this.direction };

                const newHead = {
                    x: this.head.x + this.direction.x,
                    y: this.head.y + this.direction.y
                };

                this.body.unshift(newHead);

                if (this.growQueue > 0) {
                    this.growQueue--;
                } else {
                    this.body.pop();
                }
            }

            grow(segments = 1) {
                this.growQueue += segments;
            }

            checkWallCollision() {
                return this.head.x < 0 || this.head.x >= GRID_WIDTH ||
                       this.head.y < 0 || this.head.y >= GRID_HEIGHT;
            }

            checkSelfCollision() {
                return this.body.slice(1).some(seg =>
                    seg.x === this.head.x && seg.y === this.head.y
                );
            }

            checkCollisionWith(other) {
                return other.body.some(seg =>
                    seg.x === this.head.x && seg.y === this.head.y
                );
            }

            occupies(pos) {
                return this.body.some(seg => seg.x === pos.x && seg.y === pos.y);
            }

            draw(ctx) {
                if (!this.alive) return;

                const gradient = this.colors.primary;
                const secondary = this.colors.secondary;

                // Draw glow for player
                if (this.isPlayer && this.colors.glow) {
                    ctx.shadowColor = this.colors.glow;
                    ctx.shadowBlur = 15;
                }

                // Draw body segments
                this.body.forEach((seg, i) => {
                    const isHead = i === 0;
                    const size = isHead ? CELL_SIZE - 2 : CELL_SIZE - 4;
                    const offset = isHead ? 1 : 2;

                    // Segment color gradient based on position
                    const t = i / this.body.length;
                    ctx.fillStyle = isHead ? gradient : this.lerpColor(gradient, secondary, t * 0.5);

                    // Draw rounded rectangle
                    const x = seg.x * CELL_SIZE + offset;
                    const y = seg.y * CELL_SIZE + offset;
                    const radius = isHead ? 6 : 4;

                    ctx.beginPath();
                    ctx.roundRect(x, y, size, size, radius);
                    ctx.fill();

                    // Draw eyes on head
                    if (isHead) {
                        ctx.shadowBlur = 0;
                        this.drawEyes(ctx, seg);
                    }
                });

                ctx.shadowBlur = 0;
            }

            drawEyes(ctx, head) {
                const centerX = head.x * CELL_SIZE + CELL_SIZE / 2;
                const centerY = head.y * CELL_SIZE + CELL_SIZE / 2;

                const eyeOffset = 4;
                const eyeSize = 3;
                const pupilSize = 1.5;

                let eye1, eye2;

                if (this.eyeDirection.x !== 0) {
                    eye1 = { x: centerX + this.eyeDirection.x * 3, y: centerY - eyeOffset };
                    eye2 = { x: centerX + this.eyeDirection.x * 3, y: centerY + eyeOffset };
                } else {
                    eye1 = { x: centerX - eyeOffset, y: centerY + this.eyeDirection.y * 3 };
                    eye2 = { x: centerX + eyeOffset, y: centerY + this.eyeDirection.y * 3 };
                }

                [eye1, eye2].forEach(eye => {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(eye.x, eye.y, eyeSize, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(eye.x + this.eyeDirection.x, eye.y + this.eyeDirection.y, pupilSize, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            lerpColor(color1, color2, t) {
                const c1 = this.hexToRgb(color1);
                const c2 = this.hexToRgb(color2);
                const r = Math.round(c1.r + (c2.r - c1.r) * t);
                const g = Math.round(c1.g + (c2.g - c1.g) * t);
                const b = Math.round(c1.b + (c2.b - c1.b) * t);
                return `rgb(${r},${g},${b})`;
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }
        }

        // ============================================
        // AI CONTROLLER
        // ============================================
        class AIController {
            constructor(snake, personality = 'balanced') {
                this.snake = snake;
                this.personality = personality;
                this.state = 'seeking';
                this.target = null;
                this.decisionTimer = 0;
                this.decisionInterval = 0.2;
            }

            update(deltaTime, gameState) {
                this.decisionTimer += deltaTime;

                if (this.decisionTimer >= this.decisionInterval) {
                    this.decisionTimer = 0;
                    this.makeDecision(gameState);
                }
            }

            makeDecision(gameState) {
                const { player, aiSnakes, food } = gameState;
                const threats = this.detectThreats([player, ...aiSnakes]);
                const prey = this.detectPrey([player, ...aiSnakes]);
                const nearestFood = this.findNearestFood(food);

                // Priority-based decision making
                if (threats.length > 0 && this.personality !== 'aggressive') {
                    this.state = 'fleeing';
                    this.fleeFrom(threats[0]);
                } else if (prey.length > 0 && this.shouldHunt()) {
                    this.state = 'hunting';
                    this.huntTarget(prey[0]);
                } else if (nearestFood) {
                    this.state = 'seeking';
                    this.seekTarget(nearestFood);
                } else {
                    this.state = 'wandering';
                    this.wander();
                }
            }

            detectThreats(snakes) {
                const mySize = this.snake.length;
                return snakes.filter(s =>
                    s && s.alive && s !== this.snake &&
                    s.length > mySize * 1.3 &&
                    distance(this.snake.head, s.head) < 10
                ).sort((a, b) =>
                    distance(this.snake.head, a.head) - distance(this.snake.head, b.head)
                );
            }

            detectPrey(snakes) {
                const mySize = this.snake.length;
                return snakes.filter(s =>
                    s && s.alive && s !== this.snake &&
                    mySize > s.length * 1.3 &&
                    distance(this.snake.head, s.head) < 12
                ).sort((a, b) =>
                    distance(this.snake.head, a.head) - distance(this.snake.head, b.head)
                );
            }

            shouldHunt() {
                if (this.personality === 'timid') return this.snake.length > 15;
                if (this.personality === 'aggressive') return true;
                return this.snake.length > 8;
            }

            findNearestFood(foodItems) {
                if (foodItems.length === 0) return null;
                return foodItems.reduce((nearest, f) => {
                    const d = distance(this.snake.head, f.position);
                    return d < distance(this.snake.head, nearest.position) ? f : nearest;
                }, foodItems[0]);
            }

            seekTarget(target) {
                const pos = target.position || target.head;
                this.moveToward(pos);
            }

            huntTarget(prey) {
                this.moveToward(prey.head);
            }

            fleeFrom(threat) {
                const dx = this.snake.head.x - threat.head.x;
                const dy = this.snake.head.y - threat.head.y;

                const fleeTarget = {
                    x: this.snake.head.x + Math.sign(dx) * 5,
                    y: this.snake.head.y + Math.sign(dy) * 5
                };

                this.moveToward(fleeTarget, true);
            }

            wander() {
                if (Math.random() < 0.1) {
                    const directions = [
                        { x: 1, y: 0 }, { x: -1, y: 0 },
                        { x: 0, y: 1 }, { x: 0, y: -1 }
                    ];
                    const valid = directions.filter(d =>
                        d.x !== -this.snake.direction.x || d.y !== -this.snake.direction.y
                    );
                    const dir = valid[randomInt(0, valid.length - 1)];
                    this.snake.setDirection(dir);
                }
            }

            moveToward(target, fleeing = false) {
                const head = this.snake.head;
                const dx = target.x - head.x;
                const dy = target.y - head.y;

                const possibleMoves = [];

                if (dx > 0) possibleMoves.push({ x: 1, y: 0, priority: Math.abs(dx) });
                if (dx < 0) possibleMoves.push({ x: -1, y: 0, priority: Math.abs(dx) });
                if (dy > 0) possibleMoves.push({ x: 0, y: 1, priority: Math.abs(dy) });
                if (dy < 0) possibleMoves.push({ x: 0, y: -1, priority: Math.abs(dy) });

                // Sort by priority (prefer larger distance to close)
                possibleMoves.sort((a, b) => b.priority - a.priority);

                // Filter out reverse direction and dangerous moves
                const safeMoves = possibleMoves.filter(move => {
                    if (move.x === -this.snake.direction.x && move.y === -this.snake.direction.y) {
                        return false;
                    }
                    const nextPos = { x: head.x + move.x, y: head.y + move.y };
                    return !this.isDangerous(nextPos);
                });

                if (safeMoves.length > 0) {
                    this.snake.setDirection(safeMoves[0]);
                } else {
                    // Emergency: try any safe direction
                    const allDirs = [
                        { x: 1, y: 0 }, { x: -1, y: 0 },
                        { x: 0, y: 1 }, { x: 0, y: -1 }
                    ];
                    const emergency = allDirs.find(d => {
                        if (d.x === -this.snake.direction.x && d.y === -this.snake.direction.y) return false;
                        const nextPos = { x: head.x + d.x, y: head.y + d.y };
                        return !this.isDangerous(nextPos);
                    });
                    if (emergency) this.snake.setDirection(emergency);
                }
            }

            isDangerous(pos) {
                // Wall collision
                if (pos.x < 0 || pos.x >= GRID_WIDTH || pos.y < 0 || pos.y >= GRID_HEIGHT) {
                    return true;
                }
                // Self collision
                if (this.snake.body.some(seg => seg.x === pos.x && seg.y === pos.y)) {
                    return true;
                }
                return false;
            }
        }

        // ============================================
        // FOOD CLASS
        // ============================================
        class Food {
            constructor(x, y, isGolden = false) {
                this.position = { x, y };
                this.isGolden = isGolden;
                this.value = isGolden ? 5 : 1;
                this.segments = isGolden ? 2 : 1;
                this.pulsePhase = Math.random() * Math.PI * 2;
            }

            update(deltaTime) {
                this.pulsePhase += deltaTime * 3;
            }

            draw(ctx) {
                const x = this.position.x * CELL_SIZE + CELL_SIZE / 2;
                const y = this.position.y * CELL_SIZE + CELL_SIZE / 2;
                const pulse = 1 + Math.sin(this.pulsePhase) * 0.15;
                const baseSize = this.isGolden ? 7 : 5;
                const size = baseSize * pulse;

                // Glow
                ctx.shadowColor = this.isGolden ? COLORS.food.glow : 'rgba(251, 191, 36, 0.3)';
                ctx.shadowBlur = this.isGolden ? 20 : 10;

                ctx.fillStyle = this.isGolden ? COLORS.food.golden : COLORS.food.standard;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();

                // Inner highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.beginPath();
                ctx.arc(x - 2, y - 2, size * 0.4, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
            }
        }

        // ============================================
        // GAME CLASS
        // ============================================
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');

                this.difficulty = 'balanced';
                this.state = 'menu';
                this.player = null;
                this.aiSnakes = [];
                this.aiControllers = [];
                this.food = [];
                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('ecosystemSnakeHighScore')) || 0;
                this.gameTime = 0;
                this.foodSpawnTimer = 0;
                this.stats = { snakesEaten: 0, foodCollected: 0, maxSize: 3 };

                this.lastTime = 0;
                this.effects = [];

                this.setupUI();
                this.setupInput();
                this.updateHighScoreDisplay();

                requestAnimationFrame((t) => this.gameLoop(t));
            }

            setupUI() {
                document.getElementById('startBtn').onclick = () => this.startGame();
                document.getElementById('resumeBtn').onclick = () => this.resume();
                document.getElementById('restartBtn').onclick = () => this.startGame();
                document.getElementById('playAgainBtn').onclick = () => this.startGame();

                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.onclick = () => {
                        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        this.difficulty = btn.dataset.difficulty;
                    };
                });
            }

            setupInput() {
                document.addEventListener('keydown', (e) => {
                    if (this.state === 'playing') {
                        switch(e.key) {
                            case 'ArrowUp': case 'w': case 'W':
                                this.player.setDirection({ x: 0, y: -1 });
                                e.preventDefault();
                                break;
                            case 'ArrowDown': case 's': case 'S':
                                this.player.setDirection({ x: 0, y: 1 });
                                e.preventDefault();
                                break;
                            case 'ArrowLeft': case 'a': case 'A':
                                this.player.setDirection({ x: -1, y: 0 });
                                e.preventDefault();
                                break;
                            case 'ArrowRight': case 'd': case 'D':
                                this.player.setDirection({ x: 1, y: 0 });
                                e.preventDefault();
                                break;
                            case 'p': case 'P':
                                this.pause();
                                break;
                        }
                    } else if (this.state === 'paused' && (e.key === 'p' || e.key === 'P')) {
                        this.resume();
                    }
                });
            }

            startGame() {
                const settings = DIFFICULTY_SETTINGS[this.difficulty];

                this.state = 'playing';
                this.score = 0;
                this.gameTime = 0;
                this.foodSpawnTimer = 0;
                this.stats = { snakesEaten: 0, foodCollected: 0, maxSize: 3 };
                this.effects = [];

                // Create player
                this.player = new Snake(
                    Math.floor(GRID_WIDTH / 4),
                    Math.floor(GRID_HEIGHT / 2),
                    true,
                    COLORS.player
                );

                // Create AI snakes
                this.aiSnakes = [];
                this.aiControllers = [];

                for (let i = 0; i < settings.aiCount; i++) {
                    this.spawnAISnake(i);
                }

                // Create initial food
                this.food = [];
                for (let i = 0; i < settings.foodMax; i++) {
                    this.spawnFood();
                }

                // Hide menus
                document.getElementById('startMenu').classList.add('hidden');
                document.getElementById('pauseMenu').classList.add('hidden');
                document.getElementById('gameOverMenu').classList.add('hidden');
            }

            spawnAISnake(index = 0, respawn = false) {
                const colors = COLORS.aiColors[index % COLORS.aiColors.length];
                const personalities = ['timid', 'balanced', 'aggressive'];
                const personality = personalities[index % 3];

                // Find spawn position away from player
                let pos;
                let attempts = 0;
                do {
                    pos = randomPosition();
                    attempts++;
                } while (
                    (this.player && distance(pos, this.player.head) < 10) &&
                    attempts < 50
                );

                const snake = new Snake(pos.x, pos.y, false, colors);
                if (respawn) {
                    snake.growQueue = 0; // Start smaller when respawning
                }

                const controller = new AIController(snake, personality);

                this.aiSnakes.push(snake);
                this.aiControllers.push(controller);
            }

            spawnFood() {
                const allPositions = [
                    ...(this.player ? this.player.body : []),
                    ...this.aiSnakes.flatMap(s => s.body),
                    ...this.food.map(f => f.position)
                ];

                const pos = randomPosition(allPositions);
                const isGolden = Math.random() < 0.1;
                this.food.push(new Food(pos.x, pos.y, isGolden));
            }

            pause() {
                if (this.state === 'playing') {
                    this.state = 'paused';
                    document.getElementById('pauseMenu').classList.remove('hidden');
                }
            }

            resume() {
                if (this.state === 'paused') {
                    this.state = 'playing';
                    document.getElementById('pauseMenu').classList.add('hidden');
                }
            }

            gameOver() {
                this.state = 'gameover';

                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('ecosystemSnakeHighScore', this.highScore);
                }

                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalTime').textContent = this.formatTime(this.gameTime);
                document.getElementById('finalSize').textContent = this.stats.maxSize;
                document.getElementById('snakesEaten').textContent = this.stats.snakesEaten;
                document.getElementById('foodCollected').textContent = this.stats.foodCollected;
                document.getElementById('gameOverMenu').classList.remove('hidden');

                this.updateHighScoreDisplay();
            }

            update(deltaTime) {
                if (this.state !== 'playing') return;

                const settings = DIFFICULTY_SETTINGS[this.difficulty];

                this.gameTime += deltaTime;

                // Update player
                this.player.update(deltaTime);

                // Update AI
                const gameState = {
                    player: this.player,
                    aiSnakes: this.aiSnakes.filter(s => s.alive),
                    food: this.food
                };

                this.aiControllers.forEach((controller, i) => {
                    if (this.aiSnakes[i] && this.aiSnakes[i].alive) {
                        controller.update(deltaTime, gameState);
                        this.aiSnakes[i].update(deltaTime, settings.aiSpeed);
                    }
                });

                // Update food
                this.food.forEach(f => f.update(deltaTime));

                // Food spawning
                this.foodSpawnTimer += deltaTime * 1000;
                if (this.foodSpawnTimer >= settings.foodSpawnRate && this.food.length < settings.foodMax) {
                    this.foodSpawnTimer = 0;
                    this.spawnFood();
                }

                // Check collisions
                this.checkCollisions();

                // Respawn dead AI snakes
                this.aiSnakes.forEach((snake, i) => {
                    if (!snake.alive && !snake.respawnTimer) {
                        snake.respawnTimer = 10;
                    } else if (snake.respawnTimer) {
                        snake.respawnTimer -= deltaTime;
                        if (snake.respawnTimer <= 0) {
                            this.aiSnakes.splice(i, 1);
                            this.aiControllers.splice(i, 1);
                            this.spawnAISnake(i, true);
                        }
                    }
                });

                // Update stats
                this.stats.maxSize = Math.max(this.stats.maxSize, this.player.length);

                // Survival score
                if (Math.floor(this.gameTime) % 5 === 0 && Math.floor(this.gameTime) !== this.lastSurvivalBonus) {
                    this.lastSurvivalBonus = Math.floor(this.gameTime);
                    this.score += 1;
                }

                // Update effects
                this.effects = this.effects.filter(e => {
                    e.life -= deltaTime;
                    return e.life > 0;
                });

                this.updateHUD();
            }

            checkCollisions() {
                // Player wall collision
                if (this.player.checkWallCollision()) {
                    this.gameOver();
                    return;
                }

                // Player self collision
                if (this.player.checkSelfCollision()) {
                    this.gameOver();
                    return;
                }

                // Player food collision
                this.food = this.food.filter(f => {
                    if (this.player.head.x === f.position.x && this.player.head.y === f.position.y) {
                        this.player.grow(f.segments);
                        this.score += f.value;
                        this.stats.foodCollected++;
                        this.addEffect(f.position, 'eat');
                        return false;
                    }
                    return true;
                });

                // AI food collision
                this.aiSnakes.forEach(snake => {
                    if (!snake.alive) return;

                    this.food = this.food.filter(f => {
                        if (snake.head.x === f.position.x && snake.head.y === f.position.y) {
                            snake.grow(f.segments);
                            return false;
                        }
                        return true;
                    });

                    // AI wall collision
                    if (snake.checkWallCollision() || snake.checkSelfCollision()) {
                        this.killSnake(snake);
                    }
                });

                // Snake vs snake collisions
                const allSnakes = [this.player, ...this.aiSnakes.filter(s => s.alive)];

                allSnakes.forEach(snake => {
                    if (!snake.alive) return;

                    allSnakes.forEach(other => {
                        if (snake === other || !other.alive) return;

                        // Check if snake's head hits other's body
                        if (other.body.slice(1).some(seg =>
                            seg.x === snake.head.x && seg.y === snake.head.y
                        )) {
                            // Head hit body - snake dies
                            if (snake.isPlayer) {
                                this.gameOver();
                                return;
                            } else {
                                this.killSnake(snake);
                            }
                        }

                        // Head to head collision
                        if (snake.head.x === other.head.x && snake.head.y === other.head.y) {
                            if (snake.length > other.length * 1.3) {
                                // Snake eats other
                                if (snake.isPlayer) {
                                    this.score += 10 * other.length;
                                    this.stats.snakesEaten++;
                                }
                                snake.grow(Math.floor(other.length * 0.5));
                                this.killSnake(other);
                            } else if (other.length > snake.length * 1.3) {
                                // Other eats snake
                                if (other.isPlayer) {
                                    this.score += 10 * snake.length;
                                    this.stats.snakesEaten++;
                                }
                                other.grow(Math.floor(snake.length * 0.5));
                                if (snake.isPlayer) {
                                    this.gameOver();
                                    return;
                                }
                                this.killSnake(snake);
                            }
                        }
                    });
                });
            }

            killSnake(snake) {
                snake.alive = false;

                // Drop food at death location
                const drops = Math.min(3, Math.floor(snake.length / 3));
                for (let i = 0; i < drops; i++) {
                    const seg = snake.body[Math.floor(Math.random() * snake.body.length)];
                    if (seg) {
                        this.food.push(new Food(seg.x, seg.y, false));
                    }
                }

                this.addEffect(snake.head, 'death');
            }

            addEffect(pos, type) {
                this.effects.push({
                    x: pos.x * CELL_SIZE + CELL_SIZE / 2,
                    y: pos.y * CELL_SIZE + CELL_SIZE / 2,
                    type,
                    life: 0.5
                });
            }

            updateHUD() {
                document.getElementById('scoreDisplay').textContent = this.score;
                document.getElementById('sizeDisplay').textContent = this.player.length;
                document.getElementById('timeDisplay').textContent = this.formatTime(this.gameTime);
                document.getElementById('snakeCount').textContent =
                    1 + this.aiSnakes.filter(s => s.alive).length;
            }

            updateHighScoreDisplay() {
                document.getElementById('highScoreDisplay').textContent = this.highScore;
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            draw() {
                const ctx = this.ctx;

                // Clear canvas
                ctx.fillStyle = COLORS.background;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Draw grid
                ctx.strokeStyle = COLORS.gridLines;
                ctx.lineWidth = 1;
                for (let x = 0; x <= GRID_WIDTH; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * CELL_SIZE, 0);
                    ctx.lineTo(x * CELL_SIZE, CANVAS_HEIGHT);
                    ctx.stroke();
                }
                for (let y = 0; y <= GRID_HEIGHT; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * CELL_SIZE);
                    ctx.lineTo(CANVAS_WIDTH, y * CELL_SIZE);
                    ctx.stroke();
                }

                if (this.state === 'playing' || this.state === 'paused' || this.state === 'gameover') {
                    // Draw food
                    this.food.forEach(f => f.draw(ctx));

                    // Draw AI snakes
                    this.aiSnakes.forEach(snake => snake.draw(ctx));

                    // Draw player
                    this.player.draw(ctx);

                    // Draw effects
                    this.effects.forEach(e => {
                        const alpha = e.life * 2;
                        const size = (1 - e.life) * 30 + 10;

                        ctx.strokeStyle = e.type === 'death'
                            ? `rgba(239, 68, 68, ${alpha})`
                            : `rgba(251, 191, 36, ${alpha})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(e.x, e.y, size, 0, Math.PI * 2);
                        ctx.stroke();
                    });
                }
            }

            gameLoop(currentTime) {
                const deltaTime = Math.min((currentTime - this.lastTime) / 1000, 0.1);
                this.lastTime = currentTime;

                this.update(deltaTime);
                this.draw();

                requestAnimationFrame((t) => this.gameLoop(t));
            }
        }

        // Start the game
        const game = new Game();
    </script>
</body>
</html>
